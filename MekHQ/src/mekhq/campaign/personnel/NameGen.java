package mekhq.campaign.personnel;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;
import java.util.Vector;

/**This name generator has now been replaced with the one used by MegaMek**/

public class NameGen {
	private Vector<String> _names;
	private Vector<String> _surnames;
	private Vector<String> _patterns;
	private static Random _rng;
	
	/*
	 * This function is used as an example of how to initialize the object.
	 * Actually, it was used for testing functionality, but it works as well for this purpose.
	public static void main(String[] args) {
		NameGen ng = new NameGen();
		ng.populatePatterns("namePatterns.txt");
		ng.populateNames("firstNames.txt", "lastNames.txt");
		
		for (int x=0; x<50; x++)
			System.out.println(ng.generate());
	}
	*/

	/*
	 * Default version function to populate name vectors.
	 * Primarily used for testing purposes, since it uses a small number of odd names.
	 * Acts as a pass-through to populateNames(String[])
	 */
	public void populateNames() {
		// If we hit this, then just throw in a boring name to make it work.
		String[] strs = { "Roy Fokker",
				"John Doe",
				"Doogie Howser",
				"Doogie Howitzer",
				"Joe Bloggs",
				"Jimmy Cougan",
				"Jane Doe",
				"Clark Kent",
				"Bruce Wayne",};

		populateNames(strs);
	}

	/**
	 * Version of populateNames to handle string-array population of pattern name generation.
	 * Name components and patterns must be passed in separately.
	 * Names will be generated by using a random pattern,
	 * and then replacing f and l tags with random values from the first and last name vectors. 
	 * 
	 * @param inNames List of first names to save to names vector.
	 * @param inSurnames List of surnames to save to surnames vector.
	 * @param inPatterns List of name patterns to save to patterns vector.
	 */
	public void populateNames(String[] inNames, String[] inSurnames, String[] inPatterns) {
		if (_patterns == null)
			_patterns = new Vector<String>();
	
		fillVector(inPatterns, _patterns);
		populateNames(inNames, inSurnames);
	}
	
	/**
	 * Version of populateNames to handle simple first/last name generation.
	 * Names will be generated by using a random first name and random last name from their respective vectors.
	 * 
	 * @param inNames List of first names to save to names vector.
	 * @param inSurnames List of surnames to save to surnames vector.
	 */
	public void populateNames(String[] inNames, String[] inSurnames) {
		if (_surnames == null)
			_surnames = new Vector<String>();
	
		fillVector(inSurnames, _surnames);
		populateNames(inNames);
	}
	
	/**
	 * Version of populateNames to handle simple name generation.
	 * Names will be created by using a random value from the names vector when initialized this way.
	 * 
	 * @param inNames List of name strings to save to names vector.
	 */
	public void populateNames(String[] inNames) {
		if (_names == null)
			_names = new Vector<String>();
		
		fillVector(inNames, _names);
	}
	
	/**
	 * Version of populateNames utilizing file-names to load values from.
	 * 
	 * @param firstNamesFile The name of the resource file to load first names from.
	 * @param lastNamesFile The name of the resource file to load last names from.
	 * @param patternsFile The name of the resource file to load name patterns from.
	 */
	public void populateNames(String firstNamesFile, String lastNamesFile, String patternsFile) {
		populatePatterns(patternsFile);
		populateNames(firstNamesFile, lastNamesFile);
	}
	
	/**
	 * Version of populateNames utilizing file-names to load values from.
	 * 
	 * @param firstNamesFile The name of the resource file to load first names from.
	 * @param lastNamesFile The name of the resource file to load last names from.
	 */
	public void populateNames(String firstNamesFile, String lastNamesFile) {
		InputStream stream1 = NameGen.class.getResourceAsStream(firstNamesFile);
		InputStream stream2 = NameGen.class.getResourceAsStream(lastNamesFile);
		populateNames(stream1, stream2);
	}
	
	/**
	 * Version of populateNames utilizing input streams to load values from.
	 *  
	 * @param inFirstNames Input stream to read first name strings from.
	 * @param inLastNames Input stream to read surname strings from.
	 */
	public void populateNames(InputStream inFirstNames, InputStream inLastNames) {
		if (_names == null)
			_names = new Vector<String>();
		
		Scanner input = null;
		input = new Scanner(inFirstNames);
		
		while (input.hasNextLine())
			_names.add(input.nextLine());

		if (_surnames == null)
			_surnames = new Vector<String>();
		
		input = new Scanner(inLastNames);
		
		while (input.hasNextLine())
			_surnames.add(input.nextLine());
	}

	/**
	 * Utility function to fill a vector with the elements of an array.
	 * 
	 * @param inNames
	 * @param vector
	 */
	private void fillVector(String[] inNames, Vector<String> vector) {
		vector.addAll(Arrays.asList(inNames));
	}

	/**
	 * Generates a single random name and returns it as a string.
	 * Uses a method found by looking at the state of the three vectors.
	 * If the patterns vector has contents, it uses a random pattern to generate it;
	 * If the patterns vector is empty but both names and surnames have contents, picks a random first and separate random last name;
	 * And if only the names vector has contents, picks a single random entry from it.
	 * 
	 * @return The generated name, using whatever method.
	 */
	public String generate() {
		if ((_patterns != null) && (_patterns.size() > 0)) {
			// If our name template vector isn't empty, use it!
			return generateNameFromPattern();
		}
		
		// If the names vector isn't empty, use that.
		if ((_names != null) && (_names.size() > 0)) {
			if ((_surnames != null) && (_surnames.size() > 0)){
				String retVal = _names.get(getRNG().nextInt(_names.size()))
						+ " "
						+ _surnames.get(getRNG().nextInt(_surnames.size()));

				return retVal;
			}
				
			return _names.get(getRNG().nextInt(_names.size()));
		}
		
		// If all else fails, return null!
		// This is essentially a failure, but not treated as an error.
		return null;
	}

	/**
	 * Generates a name from a pattern.
	 * Extracted out of the generate() function simply for code readability.
	 * 
	 * @return The generated name as a string.
	 */
	private String generateNameFromPattern() {
		String retVal = _patterns.get(getRNG().nextInt(_patterns.size()));
		
		while (retVal.indexOf("<f>") >= 0)
			retVal = retVal.replaceFirst("<f>", _names.get(getRNG().nextInt(_names.size())));
		
		while (retVal.indexOf("<l>") >= 0)
			retVal = retVal.replaceFirst("<l>", _surnames.get(getRNG().nextInt(_surnames.size())));
		
		return retVal;
	}

	/**
	 * Populates the name patterns vector using a given resource file to load from.
	 * 
	 * @param fileName The name of the resource file.
	 */
	public void populatePatterns(String fileName) {
		InputStream stream = NameGen.class.getResourceAsStream(fileName);
		populatePatterns(stream);
	}

	/**
	 * Populates the name patterns vector given an input stream to read pattern strings from.
	 * 
	 * @param inPatterns The input stream to read name patterns from as strings.
	 */
	public void populatePatterns(InputStream inPatterns) {
		if (_patterns == null)
			_patterns = new Vector<String>();
		
		Scanner input = null;
		input = new Scanner(inPatterns);
		
		while (input.hasNextLine())
			_patterns.add(input.nextLine());
	}
	
	/**
	 * Populates the name patterns vector given an array of strings containing the patterns desired.
	 * 
	 * @param inPatterns The array of patterns to include.
	 */
	public void populatePatterns(String[] inPatterns) {
		if (_patterns == null)
			_patterns = new Vector<String>();
		
		fillVector(inPatterns, _patterns);
	}
	
	/**
	 * Helper function to allow a single call for an RNG,
	 * guaranteeing it never creates more than one but that one is always available.
	 * 
	 * @return The static RNG stored by this class.
	 */
	private Random getRNG() {
		if (_rng == null)
			_rng = new Random();
		
		return _rng;
	}
}
